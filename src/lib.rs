use std::{
    collections::{BTreeMap, VecDeque, btree_map},
    sync::{Arc, Mutex},
};

pub mod application;
pub mod failoverunit;
pub mod node;
pub mod scheduler;
pub mod searcher;
pub mod service;
pub mod servicetype;
pub mod solver;

use application::application::Application;
use failoverunit::failover_unit::FailoverUnit;
use node::{node::Node, node_description::NodeDescription};
use node::node_id::NodeId;
use scheduler::PLBScheduler;
use service::service::Service;
use servicetype::service_type::ServiceType;

use std::cmp::Ordering;

use anyhow::Result;
use searcher::Searcher;
use solver::Solver;
use time::OffsetDateTime;
use uuid::Uuid;

pub struct LoadOrMoveCost;

struct UpdateQueue {
    node_update_queue: VecDeque<Node>,
    app_update_queue: VecDeque<Application>,
    service_type_update_queue: VecDeque<ServiceType>,
    service_update_queue: VecDeque<Service>,
    failover_unit_update_queue: VecDeque<FailoverUnit>,
    load_update_queue: VecDeque<LoadOrMoveCost>,
}

/// Similar to the C++ implementation. This is the main entry point of the entire PLB engine.
/// It consists of all the required data structures to basically does 3 things:
///     1. Listen to update cluster info API calls
///     2. Run the PLB refresh loop
///     3. Schedule searches and solutions if required
pub struct PlacementAndLoadBalancing {
    nodes: BTreeMap<NodeId, Node>,
    apps: BTreeMap<String, Application>,
    service_types: BTreeMap<String, ServiceType>,
    services: BTreeMap<String, Service>,
    failover_units: BTreeMap<Uuid, FailoverUnit>,
    loads: BTreeMap<Uuid, LoadOrMoveCost>,

    scheduler: PLBScheduler,

    searcher: Searcher,
    solver: Solver,

    /// PLB cannot operate on stale operation, but also cannot be interrupted by the new update when searching for solutions
    /// This update queue is guarded by a single mutex and is read by PLB on the start of the refresh
    plb_update_queue: Arc<Mutex<UpdateQueue>>,
}

impl Default for PlacementAndLoadBalancing {
    fn default() -> Self {
        Self::new()
    }
}

impl PlacementAndLoadBalancing {
    /// Initializes the PlacementAndLoadBalancing object with the required cluster information:
    ///     - Nodes
    ///     - Applications
    ///     - Service types
    ///     - Services
    ///     - Failover units
    ///     - Loads or move costs
    pub fn new() -> Self {
        unimplemented!()
    }

    pub fn update_node() {
        unimplemented!()
    }

    pub fn delete_node() {
        unimplemented!()
    }

    pub fn update_application() {
        unimplemented!()
    }

    pub fn delete_application() {
        unimplemented!()
    }

    pub fn update_service_type() {
        unimplemented!()
    }

    pub fn delete_service_type() {
        unimplemented!()
    }

    pub fn update_service() {
        unimplemented!()
    }

    pub fn delete_service() {
        unimplemented!()
    }

    pub fn update_failover_unit() {
        unimplemented!()
    }

    pub fn delete_failover_unit() {
        unimplemented!()
    }

    pub fn update_load_or_move_cost() {
        unimplemented!()
    }

    /// Refresh the PLB data structures from the pending update queues.
    /// It also triggers PLBSchedular to schedule any searcher stages if any stages are due at the current timestamp of the refresh (now)
    pub fn refresh(&mut self, now: OffsetDateTime) -> Result<()> {
        // Update PLB internal data structures to sync with the latest cluster information
        {
            let update_queue_clone = Arc::clone(&self.plb_update_queue);
            let mut update_queue = update_queue_clone.lock().unwrap();

            // Copy over the updates to the PLB structure for snapshot
            self.process_node_updates(&mut update_queue.node_update_queue);
            self.process_app_updates(&mut update_queue.app_update_queue);
            self.process_service_type_updates(&mut update_queue.service_type_update_queue);
            self.process_service_updates(&mut update_queue.service_update_queue);
            self.process_failover_unit_updates(&mut update_queue.failover_unit_update_queue);
            self.process_load_updates(&mut update_queue.load_update_queue);
        }

        // Let scheduler decide what phases will be run in this refresh
        // TODO: this should be run on each service domain, but for simplicity we can pack everything into one service domain
        let phases = self.scheduler.get_current_phases(now);

        let mut solutions = vec![];
        // For each phase generated by the scheduler, 
        //  1. active PLB searcher to search for any actions
        //  2. activate solver to generate any solutions
        for phase in phases {
            let actions = self.searcher.generate_actions(phase);
            solutions = self.solver.generate_solutions(actions);
        }

        // TODO: give action generated by the solver back to FM (this will just be printing out the solution to the console for now)
        println!("Solutions generated: {:?}", solutions);

        Ok(())
    }

    fn process_node_updates(&mut self, node_updates: &mut VecDeque<Node>) {
        while !node_updates.is_empty() {
            let node_update = node_updates.pop_front().unwrap();
            let node_id = node_update.node_id();
            self.nodes.insert(node_id, node_update);
        }
    }

    fn process_app_updates(&mut self, app_updates: &mut VecDeque<Application>) {
        while !app_updates.is_empty() {
            let app_update = app_updates.pop_front().unwrap();
            let app_name = app_update.app_name();
            self.apps.insert(String::from(app_name), app_update);
        }
    }

    fn process_service_type_updates(&mut self, service_type_updates: &mut VecDeque<ServiceType>) {
        unimplemented!()
    }

    fn process_service_updates(&mut self, service_updates: &mut VecDeque<Service>) {
        unimplemented!()
    }

    fn process_failover_unit_updates(&mut self, failover_unit_updates: &mut VecDeque<FailoverUnit>) {
        unimplemented!()
    }

    fn process_load_updates(&mut self, load_updates: &mut VecDeque<LoadOrMoveCost>) {
        unimplemented!()
    }

    /// Given a failover unit and 2 candicate secondary replicas, return the comparision result for promoting to primary
    /// A negative return value means Node 1 is preferred; a positive return value means Node 2 is preferred; 0 return value means
    /// 2 candidate nodes are equally preferred.
    ///
    /// The default CNFP algorithm is Dummy PLB
    /// TODO: add more CNFP algorithms and make an interface for user to choose
    pub fn compare_node_for_promotion(
        &self,
        _service_name: &str,
        _fu_id: Uuid,
        node1: NodeId,
        node2: NodeId,
    ) -> i32 {
        match node1.cmp(node2) {
            Ordering::Less => -1,
            Ordering::Equal => 0,
            Ordering::Greater => 1,
        }
    }
}
