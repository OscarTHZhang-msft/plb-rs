use std::{
    collections::{BTreeMap, VecDeque},
    sync::{Arc, Mutex},
};

pub mod application;
pub mod failoverunit;
pub mod node;
pub mod scheduler;
pub mod searcher;
pub mod service;
pub mod servicetype;
pub mod solver;

use application::application::Application;
use failoverunit::failover_unit::FailoverUnit;
use node::node::Node;
use node::node_id::NodeId;
use scheduler::PLBScheduler;
use service::service::Service;
use servicetype::service_type::ServiceType;

use std::cmp::Ordering;

use anyhow::Result;
use searcher::Searcher;
use solver::Solver;
use time::OffsetDateTime;
use uuid::Uuid;

pub struct LoadOrMoveCost;

struct UpdateQueue {
    node_update_queue: VecDeque<Node>,
    app_update_queue: VecDeque<Application>,
    service_type_update_queue: VecDeque<ServiceType>,
    service_update_queue: VecDeque<Service>,
    failover_unit_update_queue: VecDeque<FailoverUnit>,
    load_update_queue: VecDeque<LoadOrMoveCost>,
}

/// Similar to the C++ implementation. This is the main entry point of the entire PLB engine.
/// It consists of all the required data structures to basically does 3 things:
///     1. Listen to update cluster info API calls
///     2. Run the PLB refresh loop
///     3. Schedule searches and solutions if required
pub struct PlacementAndLoadBalancing {
    nodes: BTreeMap<NodeId, Node>,
    apps: BTreeMap<String, Application>,
    service_types: BTreeMap<String, ServiceType>,
    services: BTreeMap<String, Service>,
    failover_units: BTreeMap<Uuid, FailoverUnit>,
    loads: BTreeMap<Uuid, LoadOrMoveCost>,

    scheduler: PLBScheduler,

    searcher: Searcher,
    solver: Solver,

    /// PLB cannot operate on stale operation, but also cannot be interrupted by the new update when searching for solutions
    /// This update queue is guarded by a single mutex and is read by PLB on the start of the refresh
    plb_update_queue: Arc<Mutex<UpdateQueue>>,
}

impl Default for PlacementAndLoadBalancing {
    fn default() -> Self {
        Self::new()
    }
}

impl PlacementAndLoadBalancing {
    /// Initializes the PlacementAndLoadBalancing object with the required cluster information:
    ///     - Nodes
    ///     - Applications
    ///     - Service types
    ///     - Services
    ///     - Failover units
    ///     - Loads or move costs
    pub fn new() -> Self {
        unimplemented!()
    }

    pub fn update_node() {
        unimplemented!()
    }

    pub fn delete_node() {
        unimplemented!()
    }

    pub fn update_application() {
        unimplemented!()
    }

    pub fn delete_application() {
        unimplemented!()
    }

    pub fn update_service_type() {
        unimplemented!()
    }

    pub fn delete_service_type() {
        unimplemented!()
    }

    pub fn update_service() {
        unimplemented!()
    }

    pub fn delete_service() {
        unimplemented!()
    }

    pub fn update_failover_unit() {
        unimplemented!()
    }

    pub fn delete_failover_unit() {
        unimplemented!()
    }

    pub fn update_load_or_move_cost() {
        unimplemented!()
    }

    /// Refresh the PLB data structures from the pending update queues.
    /// It also triggers PLBSchedular to schedule any searcher stages if any stages are due at the current timestamp of the refresh (now)
    pub fn refresh(&mut self, now: OffsetDateTime) -> Result<()> {
        // Update PLB internal data structures to sync with the latest cluster information
        {
            let update_queue_clone = Arc::clone(&self.plb_update_queue);
            let mut update_queue = update_queue_clone.lock().unwrap();

            let mut node_updates = &update_queue.node_update_queue;
            let mut app_updates = &update_queue.app_update_queue;
            let mut service_type_updates = &update_queue.service_type_update_queue;
            let mut service_updates = &update_queue.service_update_queue;
            let mut failover_unit_updates = &update_queue.failover_unit_update_queue;
            let mut load_or_move_cost_updates = &update_queue.load_update_queue;

            // Copy over the updates to the PLB structure for snapshot
            todo!();
        }

        // TODO: let scheduler decide what phases will be run in this refresh
        // TODO: this should be run on each service domain, but for simplicity we can pack everything into one service domain
        let phases = self.scheduler.get_current_phases(now);

        let mut solutions = vec![];
        // TODO: for each phase  generated by the scheduler, active PLB searcher to search for any actions, and
        // activate solver to generate any solutions
        for phase in phases {
            let actions = self.searcher.generate_actions(phase);
            solutions = self.solver.generate_solutions(actions);
        }

        // TODO: give action generated by the solver back to FM (this will just be printing out the solution to the console for now)
        println!("Solutions generated: {:?}", solutions);

        Ok(())
    }

    /// Given a failover unit and 2 candicate secondary replicas, return the comparision result for promoting to primary
    /// A negative return value means Node 1 is preferred; a positive return value means Node 2 is preferred; 0 return value means
    /// 2 candidate nodes are equally preferred.
    ///
    /// The default CNFP algorithm is Dummy PLB
    /// TODO: add more CNFP algorithms and make an interface for user to choose
    pub fn compare_node_for_promotion(
        &self,
        _service_name: &str,
        _fu_id: Uuid,
        node1: NodeId,
        node2: NodeId,
    ) -> i32 {
        match node1.cmp(node2) {
            Ordering::Less => -1,
            Ordering::Equal => 0,
            Ordering::Greater => 1,
        }
    }
}
